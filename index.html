<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>한자 쓰기: 한 획씩 그리기 + 타일 저장</title>
  <script src="https://unpkg.com/hanzi-writer@2.1.2/dist/hanzi-writer.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    #writer-container {
      width: 300px;
      height: 300px;
      margin: 20px auto;
      border: 2px solid #ccc;
      border-radius: 12px;
    }
    .tile-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      margin-top: 20px;
    }
    .tile-container img {
      width: 60px;
      height: 60px;
      border: 1px solid #ccc;
    }
    button:disabled {
      opacity: 0.4;
    }
  </style>
</head>
<body>

  <h1>한자 쓰기: 한 획씩 그리기 + 타일 저장</h1>

  <input type="text" id="charInput" value="瞳" maxlength="1" style="font-size:18px;">
  <button id="loadBtn">한자 불러오기</button>
  <button id="nextStrokeBtn" disabled>다음 획 그리기</button>

  <div id="writer-container"></div>

  <div class="tile-container" id="snapshotTiles"></div>

  <script>
    let writer = null;
    let currentStrokeIndex = 0;
    let totalStrokes = 0;

    const writerContainer = document.getElementById('writer-container');
    const loadBtn = document.getElementById('loadBtn');
    const nextStrokeBtn = document.getElementById('nextStrokeBtn');
    const snapshotTiles = document.getElementById('snapshotTiles');

    // Load character
    loadBtn.addEventListener('click', async () => {
      const char = document.getElementById('charInput').value.trim();
      if (!char) return;

      writerContainer.innerHTML = '';
      snapshotTiles.innerHTML = '';
      currentStrokeIndex = 0;

      writer = HanziWriter.create('writer-container', char, {
        width: 300,
        height: 300,
        padding: 5,
        strokeAnimationSpeed: 1.2,
        delayBetweenStrokes: 300,
        showOutline: true,
        showCharacter: false,
        strokeColor: '#000'
      });

      await writer.hideCharacter();
      await writer.animateCharacter();
      await writer.showOutline();
      totalStrokes = writer.getStrokeCount();
      nextStrokeBtn.disabled = false;

      // Clear all strokes and show outline only
      await writer.hideCharacter();
      await writer.showOutline();
    });

    // Draw one stroke at a time
    nextStrokeBtn.addEventListener('click', async () => {
      if (!writer || currentStrokeIndex >= totalStrokes) {
        nextStrokeBtn.disabled = true;
        return;
      }

      await writer.animateStroke(currentStrokeIndex);
      await captureSnapshot();  // Capture after stroke
      currentStrokeIndex++;

      if (currentStrokeIndex >= totalStrokes) {
        nextStrokeBtn.disabled = true;
      }
    });

    // Capture canvas as image
    async function captureSnapshot() {
      const svgElem = writerContainer.querySelector('svg');
      const svgData = new XMLSerializer().serializeToString(svgElem);
      const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = function () {
        const canvas = document.createElement('canvas');
        canvas.width = 100;
        canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        const imgTag = document.createElement('img');
        imgTag.src = canvas.toDataURL("image/png");
        snapshotTiles.appendChild(imgTag);
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }
  </script>

</body>
</html>
