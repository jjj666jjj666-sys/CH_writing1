<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>한자 쓰기 + 자동 스냅샷</title>
  <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@latest/dist/hanzi-writer.min.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 30px;
    }

    #stage {
      width: 260px;
      height: 260px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: #fff;
    }

    #controls {
      margin: 20px 0;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #tiles {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }

    .tile {
      width: 96px;
      height: 96px;
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: #fff;
    }

    .tile img {
      width: 90px;
      height: 90px;
      object-fit: contain;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>

  <h1>한자 획순 쓰기 + 장면 저장</h1>

  <div id="controls">
    <input id="charInput" type="text" value="永" maxlength="1" />
    <button id="loadBtn">한자 불러오기</button>
    <button id="drawBtn" disabled>다음 획 그리기</button>
  </div>

  <div id="stage"></div>
  <div id="tiles"></div>

  <script>
    let writer = null;
    let currentStroke = 0;
    let totalStrokes = 0;

    // SVG → PNG 변환 후 이미지 요소 반환
    function snapshotStageToImg(size = 96) {
      const svg = document.querySelector('#stage svg');
      if (!svg) return Promise.resolve(null);

      const serializer = new XMLSerializer();
      let svgStr = serializer.serializeToString(svg);
      if (!svgStr.startsWith('<?xml')) {
        svgStr = '<?xml version="1.0" standalone="no"?>\n' + svgStr;
      }

      const svgUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
      const img = new Image();
      img.src = svgUrl;

      return new Promise(resolve => {
        img.onload = () => {
          const vb = svg.viewBox.baseVal;
          const w = vb?.width || svg.clientWidth || 260;
          const h = vb?.height || svg.clientHeight || 260;
          const scale = size / Math.max(w, h);

          const canvas = document.createElement('canvas');
          canvas.width = w * scale;
          canvas.height = h * scale;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

          const out = new Image();
          out.src = canvas.toDataURL('image/png');
          out.width = size;
          out.height = size;
          resolve(out);
        };
        img.onerror = () => resolve(null);
      });
    }

    // 이미지 타일 추가
    async function saveSnapshot() {
      const img = await snapshotStageToImg();
      if (img) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.appendChild(img);
        document.getElementById('tiles').appendChild(tile);
      }
    }

    // 한자 불러오기
    document.getElementById('loadBtn').addEventListener('click', async () => {
      const char = document.getElementById('charInput').value.trim();
      if (!char) return;

      document.getElementById('stage').innerHTML = '';
      document.getElementById('tiles').innerHTML = '';
      document.getElementById('drawBtn').disabled = true;
      currentStroke = 0;

      writer = HanziWriter.create('stage', char, {
        width: 260,
        height: 260,
        padding: 10,
        showOutline: true,
        showCharacter: false,
        strokeColor: '#333',
        delayBetweenStrokes: 0,
        strokeAnimationSpeed: 1.0,
      });

      await writer._characterLoaded;

      totalStrokes = writer.getStrokeCount();

      if (totalStrokes > 0) {
        // 첫 획 자동 그리기
        await writer.drawStroke(currentStroke);
        await saveSnapshot();
        currentStroke++;

        document.getElementById('drawBtn').disabled = false;
      }
    });

    // 다음 획 그리기 버튼
    document.getElementById('drawBtn').addEventListener('click', async () => {
      if (!writer || currentStroke >= totalStrokes) return;

      await writer.drawStroke(currentStroke);
      await saveSnapshot();
      currentStroke++;

      if (currentStroke >= totalStrokes) {
        document.getElementById('drawBtn').disabled = true;
      }
    });
  </script>

</body>
</html>
